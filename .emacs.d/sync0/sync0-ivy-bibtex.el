(require 'sync0-zettelkasten)
(require 'sync0-bibtex-utils)
(require 'consult-bibtex)

(defvar sync0-ivy-bibtex-cache nil
  "Cache variable for sync0-ivy-bibtex.")

(defvar sync0-bibtex-completion-cache-key nil
  "Cache variable to store the current BibTeX key for preselection.")

(defvar sync0-bibtex-completion-cache-pages nil
  "Cache variable to store the current BibTeX pages for preselection.")

(defvar sync0-bibtex-completion-cache-citation nil
  "Cache variable to store the last used BibTeX citation.")

(defun sync0-ivy-bibtex-update-cache ()
  "Force update sync0-ivy-bibtex-cache to reflect changes."
  (interactive)
  (bibtex-completion-init)
  (setq sync0-ivy-bibtex-cache (bibtex-completion-candidates)))

(defun sync0-bibtex-correct-crossref-fields ()
  "Correct crossref fields to prevent errors generated by the way
bibtex-completion handles crossreferences."
  (setq sync0-bibtex-entry-crossref-entry
        (bibtex-completion-get-entry sync0-bibtex-entry-crossref))
  ;; when crossref is present, load crossref fields
  (let (x)
    (dolist (element sync0-bibtex-fields x)
      (let ((value (bibtex-completion-get-value element sync0-bibtex-entry-crossref-entry))
            (var (concat "sync0-bibtex-entry-crossref-" element)))
        ;; set the variable to the value
        (set (intern var) value)
        ;; create cons of the form  ("sync0-bibtex-entry-title" . "The good old days") for an alist
        (push (cons var value) x)
        ;; added this last function to see if I can get completion to work
        (sync0-bibtex-update-var element)))
    (setq sync0-bibtex-entry-crossref-fields-alist x))
  ;; Check and fix problems with crossref-fields
  (dolist (element sync0-bibtex-entry-crossref-crosscheck-fields-list)
    (let* ((entry-element (concat "sync0-bibtex-entry-" element))
           (entry-cons (assoc entry-element sync0-bibtex-entry-fields-alist))
           (entry-value (cdr entry-cons))
           (crossref-element (concat "sync0-bibtex-entry-crossref-" element))
           (crossref-cons (assoc crossref-element sync0-bibtex-entry-crossref-fields-alist))
           (crossref-value (cdr crossref-cons)))
      (when (string= entry-value crossref-value)
        (set (intern entry-element) nil)))))

(defun sync0-bibtex-completion-get-value (field entry)
  "Fix a redefinition of bibtex-completion-get-value because it
outputs the bibtex fields with the braces {}."
      (bibtex-completion-get-value field entry))

(defun sync0-bibtex-get-value-from-entry  (bibkey bibtex-field)
  "Get content of BIBTEX-FIELD from the entry associated with
BIBKEY. Depends on bibtex-completion-get-entry from the package
helm-bibtex to work"
  (let ((bibentry (bibtex-completion-get-entry bibkey)))
	(cdr (assoc bibtex-field  bibentry))))

(defun sync0-org-ref-get-citation-author (key)
  "Get the year of an entry with KEY.  Return year as a string."
  (let* ((entry (bibtex-completion-get-entry key))
         (type (cdr (assoc "=type=" entry))))
    (if (or (equal type "collection")
            (equal type "Collection"))
        (cdr (assoc "editor" entry))
      (cdr (assoc "author" entry)))))

(defun consult-bibtex--candidates (&optional cands)
  "Convert `bibtex-completion' candidates to `completing-read' candidates.
CANDS is an optional subset of candidates to convert. When omitted CANDS
defaults to all the candidates configured by `bibtex-completion'."
  (when (null sync0-ivy-bibtex-cache)
    (sync0-ivy-bibtex-update-cache))
  (or cands
      (setq cands sync0-ivy-bibtex-cache))  ;; Use cached candidates here
  (cl-loop
   for cand in cands
   with cand-str = nil
   do (setq cand-str
            (concat (bibtex-completion-get-value "=type=" cand) " "
                    (bibtex-completion-format-entry (cdr cand) (1- (frame-width)))))
   ;; Add a `consult--type' property for narrowing support.
   do (add-text-properties 0 1
                           `(consult--type
                             ,(or
                               (when-let ((type (bibtex-completion-get-value "=type=" cand)))
                                 (car (rassoc (capitalize type) consult-bibtex-narrow)))
                               (car (rassoc "Other" consult-bibtex-narrow)))
                             ;; Symbols are more performant than strings for most situations.
                             bib-type ,(intern (capitalize (bibtex-completion-get-value "=type=" cand)))
                             consult--candidate ,(bibtex-completion-get-value "=key=" cand)
                             has-pdf ,(not (not (bibtex-completion-get-value "=has-pdf=" cand)))
                             has-note ,(not (not (bibtex-completion-get-value "=has-note=" cand))))
                           ;; The trailing type text is there for matching, it'll be removed by consult.
                           cand-str)
   collect cand-str))

(defun consult-bibtex--read-entry (&optional arg)
  "Read a bibtex entry.
Optional argument CANDS is the same as for `consult-bibtex--candidates'. ARG
causes `bibtex-completion' re-read all bibtex entries from your bibtex files."
  ;; (when arg
  ;;   (bibtex-completion-clear-cache))
  ;; (bibtex-completion-init)
  (let* ((candidates (consult-bibtex--candidates))
         (preselect
          (when-let ((key (bibtex-completion-key-at-point)))
            (cl-find-if (lambda (cand)
                          (string-equal key (get-text-property 0 'consult--candidate cand)))
                        candidates))))
    (consult--read candidates
                   :prompt "BibTeX entries: "
                   :require-match t
                   :category 'bibtex-completion
                   :lookup 'consult--lookup-candidate
                   :default preselect
                   :group
                   ;; (consult--type-title consult-bibtex-narrow)
                   (lambda (cand transform)
                     (if transform
                         (substring cand (1+ (length (symbol-name (get-text-property 0 'bib-type cand)))))
                       (symbol-name (get-text-property 0 'bib-type cand))))
                   :narrow
                   ;; Allow narrowing on PDFs and notes, alongside just `consult--type'.
                   (let ((type-narrow (plist-get (consult--type-narrow consult-bibtex-narrow) :predicate)))
                     (list :predicate
                           (lambda (cand)
                             (when consult--narrow
                               (cond
                                ((eq consult--narrow consult-bibtex-pdf-narrow-key)
                                 (get-text-property 0 'has-pdf cand))
                                ((eq consult--narrow consult-bibtex-note-narrow-key)
                                 (get-text-property 0 'has-note cand))
                                (t (funcall type-narrow cand)))))
                           :keys
                           `(,@(and consult-bibtex-pdf-narrow-key
                                    `((,consult-bibtex-pdf-narrow-key . "With PDFs")))
                             ,@(and consult-bibtex-note-narrow-key
                                    `((,consult-bibtex-note-narrow-key . "With Notes")))
                             ,@consult-bibtex-narrow)))
                   :history consult-bibtex-history)))

(defun my-consult-bibtex--read-entry (&optional prompt)
  "Read a bibtex entry.
Optional argument CANDS is the same as for `consult-bibtex--candidates'. ARG
causes `bibtex-completion' re-read all bibtex entries from your bibtex files."
  (let* ((candidates (consult-bibtex--candidates))
         (preselect
          (when-let ((key (bibtex-completion-key-at-point)))
            (cl-find-if (lambda (cand)
                          (string-equal key (get-text-property 0 'consult--candidate cand)))
                        candidates)))
	 (my-prompt (or prompt "BibTeX entries: ")))
    (consult--read candidates
                   :prompt my-prompt
                   :require-match t
                   :category 'bibtex-completion
                   :lookup 'consult--lookup-candidate
                   :default preselect
                   :group
                   ;; (consult--type-title consult-bibtex-narrow)
                   (lambda (cand transform)
                     (if transform
                         (substring cand (1+ (length (symbol-name (get-text-property 0 'bib-type cand)))))
                       (symbol-name (get-text-property 0 'bib-type cand))))
                   :narrow
                   ;; Allow narrowing on PDFs and notes, alongside just `consult--type'.
                   (let ((type-narrow (plist-get (consult--type-narrow consult-bibtex-narrow) :predicate)))
                     (list :predicate
                           (lambda (cand)
                             (when consult--narrow
                               (cond
                                ((eq consult--narrow consult-bibtex-pdf-narrow-key)
                                 (get-text-property 0 'has-pdf cand))
                                ((eq consult--narrow consult-bibtex-note-narrow-key)
                                 (get-text-property 0 'has-note cand))
                                (t (funcall type-narrow cand)))))
                           :keys
                           `(,@(and consult-bibtex-pdf-narrow-key
                                    `((,consult-bibtex-pdf-narrow-key . "With PDFs")))
                             ,@(and consult-bibtex-note-narrow-key
                                    `((,consult-bibtex-note-narrow-key . "With Notes")))
                             ,@consult-bibtex-narrow)))
                   :history consult-bibtex-history)))

(defun sync0-consult-bibtex-batch-action (keys)
  "Perform a batch action on a list of BibTeX KEYS."
  (let* ((action-name (completing-read "Choose action: " (mapcar #'car sync0-consult-bibtex-action-map)))
         (action-fn (cdr (assoc action-name sync0-consult-bibtex-action-map))))
    (if action-fn
        (funcall action-fn keys)
      (message "No valid action selected"))))

(defun sync0-consult-bibtex-multi-select (&optional cands)
  "Allow multiple selection of BibTeX entries using consult-bibtex--read-entry and return their keys.
CANDS is an optional list of candidates, which defaults to the list generated by
`consult-bibtex--candidates`."
  (interactive)
  (let ((candidates (or cands (consult-bibtex--candidates)))  ;; Get all candidates
        (selected-keys '())  ;; List to hold selected keys
        (done nil))          ;; Flag to indicate when to stop
    (while (not done)
      (let ((selected (consult-bibtex--read-entry)))
        (if selected
            (progn
              (push selected selected-keys)  ;; Add selected entry to the list
              (message "Selected entry: %s" selected))
          (setq done t)))  ;; Exit the loop if the user presses C-g or cancels
      (when (not (yes-or-no-p "Continue selecting? "))
        (setq done t)))  ;; Exit the loop if the user decides not to continue
    (message "Final selection: %s" selected-keys)
    (sync0-consult-bibtex-batch-action selected-keys)))

(evil-leader/set-key "v" 'sync0-consult-bibtex-multi-select)

(defun sync0-bibtex-completion-choose-key (&optional unique pointer query-message use-cache)
  "Allow multiple selection of BibTeX entries using consult-bibtex--read-entry and return their keys.
CANDS is an optional list of candidates, which defaults to the list generated by
`consult-bibtex--candidates`."
  (interactive)
  (let* ((entry (when (or pointer
                          (string= major-mode "bibtex-mode"))
                  (save-excursion
                    (bibtex-beginning-of-entry)
                    (bibtex-parse-entry))))
         (preselect (if entry
			(cdr (assoc "=key=" entry))
		      sync0-bibtex-choose-key-cache))
         (candidates (if use-cache
                         sync0-bibtex-completion-candidate-cache
                       (setq sync0-bibtex-completion-candidate-cache (bibtex-completion-candidates))))
	 (my-message (or query-message "Choose BibTeX key: ")))
    (if unique
        (let ((selection (my-consult-bibtex--read-entry my-message)))
	  (progn 
	    (message "Selected key: %s" selection)
	    (setq sync0-bibtex-choose-key-cache selection)))
      (let ((selected-keys '())  ;; List to hold selected keys
            (done nil))          ;; Flag to indicate when to stop
	(while (not done)
	  (let ((selected (my-consult-bibtex--read-entry my-message)))
            (if selected
		(progn
		  (push selected selected-keys)  ;; Add selected entry to the list
		  (message "Selected entry: %s" selected))
              (setq done t)))  ;; Exit the loop if the user presses C-g or cancels
	  (when (not (yes-or-no-p "Continue selecting? "))
            (setq done t)))  ;; Exit the loop if the user decides not to continue
	(message "Selected keys: %s" selected-keys)
	selected-keys))))

(defun sync0-bibtex-choose-attachment (&optional bibkey extension)
  "Choose an attachment associated with BIBKEY. Optionally filter by EXTENSION."
  (let* ((refkey (or bibkey
                     (sync0-bibtex-completion-choose-key t t "Which key to look for attachments?")))
         (file-field (sync0-bibtex-get-value-from-entry refkey "file"))
         (attachments (when file-field
			(mapcar (lambda (attachment)
				  ;; Handle cases with leading colons and split properly
				  (let* ((cleaned-attachment (string-remove-prefix ":" attachment)) ;; Remove leading colon
					 (path (car (split-string cleaned-attachment ":"))))          ;; Split by colon
				    (string-trim path)))                                             ;; Trim any excess spaces
				;; Split on semicolons, ignoring empty strings
				(split-string file-field ";" t)))))
    (cond
     ((null attachments)
      (error "No attachments found for entry %s" refkey))
     ((= (length attachments) 1)
      (car attachments))  ; Return the only attachment if there's just one
     (t
      (completing-read "Select an attachment: " attachments)))))

(defun sync0-bibtex-corrections-format-insert-citation (bibkey)
  "Format citation to insert according to conventions."
  (sync0-bibtex-completion-load-entry bibkey)
  (cond ((and (string= sync0-bibtex-entry-type-downcase "incollection")
              sync0-bibtex-entry-booktitle)
           (concat sync0-bibtex-entry-lastname
                   (or (concat " " sync0-bibtex-entry-date-fixed " ")
                       " ")
                   "*" sync0-bibtex-entry-title-fixed "*"
                   " in "
                   (when sync0-bibtex-entry-editor
                     (concat 
                      (sync0-bibtex-abbreviate-lastnames   sync0-bibtex-entry-editor)
                      ", "))
                   sync0-bibtex-entry-booktitle
                   (when sync0-bibtex-entry-volume
                     (concat 
                      ", T. "
                      sync0-bibtex-entry-volume
                      (when sync0-bibtex-entry-number
                        (concat 
                         ", No. "
                         sync0-bibtex-entry-number))))
                   (when sync0-bibtex-entry-pages
                     (concat 
                      ", p. "
                      sync0-bibtex-entry-pages))))
        ((and (string= sync0-bibtex-entry-type-downcase "article")
          sync0-bibtex-entry-booktitle)
           (concat sync0-bibtex-entry-lastname
                   (or (concat " " sync0-bibtex-entry-date-fixed " ")
                       " ")
                   "*" sync0-bibtex-entry-title-fixed "*"
                   (when sync0-bibtex-entry-volume
                     (concat 
                      ", T. "
                      sync0-bibtex-entry-volume
                      (when sync0-bibtex-entry-number
                        (concat 
                         ", No. "
                         sync0-bibtex-entry-number))))
                   (when sync0-bibtex-entry-pages
                     (concat 
                      ", p. "
                      sync0-bibtex-entry-pages))))
        ((string= sync0-bibtex-entry-type-downcase "article")
         (concat sync0-bibtex-entry-lastname
                 (or (concat " " sync0-bibtex-entry-date-fixed " ")
                     " ")
                   "*" sync0-bibtex-entry-title-fixed "*"
               " in "
               sync0-bibtex-entry-journaltitle
               (when sync0-bibtex-entry-volume
                 (concat 
                  ", T. "
                  sync0-bibtex-entry-volume
               (when sync0-bibtex-entry-number
                 (concat 
                  ", No. "
                  sync0-bibtex-entry-number))
               (when sync0-bibtex-entry-pages
                 (concat 
                  ", p. "
                  sync0-bibtex-entry-pages))))))
        ((or (string= sync0-bibtex-entry-type-downcase "incollection")
             (string= sync0-bibtex-entry-type-downcase "inproceedings"))
         (concat sync0-bibtex-entry-lastname
                 (or (concat " " sync0-bibtex-entry-date-fixed " ")
                     " ")
                   "*" sync0-bibtex-entry-title-fixed "*"
               " in "
               sync0-bibtex-entry-journaltitle
               (when sync0-bibtex-entry-volume
                 (concat 
                  ", T. "
                  sync0-bibtex-entry-volume
               (when sync0-bibtex-entry-number
                 (concat 
                  ", No. "
                  sync0-bibtex-entry-number))
               (when sync0-bibtex-entry-pages
                 (concat 
                  ", p. "
                  sync0-bibtex-entry-pages))))))
        ((string= sync0-bibtex-entry-type-downcase "inbook")
         (concat sync0-bibtex-entry-lastname
                 (or (concat " " sync0-bibtex-entry-date-fixed " ")
                     " ")
                   "*" sync0-bibtex-entry-title-fixed "*"
                 " in "
                 sync0-bibtex-entry-booktitle
                 (when sync0-bibtex-entry-volume
                   (concat 
                    ", T. "
                    sync0-bibtex-entry-volume
                    (when sync0-bibtex-entry-number
                      (concat 
                       ", No. "
                       sync0-bibtex-entry-number))))
                 (when sync0-bibtex-entry-pages
                   (concat 
                    ", p. "
                    sync0-bibtex-entry-pages))))
        (t (concat sync0-bibtex-entry-lastname
                   (or (concat " " sync0-bibtex-entry-date-fixed " ")
                       " ")
                   "*" sync0-bibtex-entry-title-fixed "*"))))

(defun sync0-bibtex-corrections-format-yank-citation (bibkey)
  "Format citation to yank according to conventions."
  (sync0-bibtex-completion-load-entry bibkey)
  (cond ((and (string= sync0-bibtex-entry-type-downcase "incollection")
              sync0-bibtex-entry-booktitle)
           (concat sync0-bibtex-entry-lastname
                   (or (concat " " sync0-bibtex-entry-date-fixed " ")
                       " ")
                   sync0-bibtex-entry-title-compatible
                   " in "
                   (when sync0-bibtex-entry-editor
                     (concat 
                      (sync0-bibtex-abbreviate-lastnames   sync0-bibtex-entry-editor)
                      ", "))
                   sync0-bibtex-entry-booktitle
                   (when sync0-bibtex-entry-volume
                     (concat 
                      ", T. "
                      sync0-bibtex-entry-volume
                      (when sync0-bibtex-entry-number
                        (concat 
                         ", No. "
                         sync0-bibtex-entry-number))))
                   (when sync0-bibtex-entry-pages
                     (concat 
                      ", p. "
                      sync0-bibtex-entry-pages))))
        ((and (string= sync0-bibtex-entry-type-downcase "article")
          sync0-bibtex-entry-booktitle)
           (concat sync0-bibtex-entry-lastname
                   (or (concat " " sync0-bibtex-entry-date-fixed " ")
                       " ")
                   sync0-bibtex-entry-title-compatible
                   (when sync0-bibtex-entry-volume
                     (concat 
                      ", T. "
                      sync0-bibtex-entry-volume
                      (when sync0-bibtex-entry-number
                        (concat 
                         ", No. "
                         sync0-bibtex-entry-number))))
                   (when sync0-bibtex-entry-pages
                     (concat 
                      ", p. "
                      sync0-bibtex-entry-pages))))
        ((string= sync0-bibtex-entry-type-downcase "article")
         (concat sync0-bibtex-entry-lastname
                 (or (concat " " sync0-bibtex-entry-date-fixed " ")
                     " ")
               sync0-bibtex-entry-title-compatible
               " in "
               sync0-bibtex-entry-journaltitle
               (when sync0-bibtex-entry-volume
                 (concat 
                  ", T. "
                  sync0-bibtex-entry-volume
               (when sync0-bibtex-entry-number
                 (concat 
                  ", No. "
                  sync0-bibtex-entry-number))
               (when sync0-bibtex-entry-pages
                 (concat 
                  ", p. "
                  sync0-bibtex-entry-pages))))))
        ((or (string= sync0-bibtex-entry-type-downcase "incollection")
             (string= sync0-bibtex-entry-type-downcase "inproceedings"))
         (concat sync0-bibtex-entry-lastname
                 (or (concat " " sync0-bibtex-entry-date-fixed " ")
                     " ")
               sync0-bibtex-entry-title-compatible
               " in "
               sync0-bibtex-entry-journaltitle
               (when sync0-bibtex-entry-volume
                 (concat 
                  ", T. "
                  sync0-bibtex-entry-volume
               (when sync0-bibtex-entry-number
                 (concat 
                  ", No. "
                  sync0-bibtex-entry-number))
               (when sync0-bibtex-entry-pages
                 (concat 
                  ", p. "
                  sync0-bibtex-entry-pages))))))
        ((string= sync0-bibtex-entry-type-downcase "inbook")
         (concat sync0-bibtex-entry-lastname
                 (or (concat " " sync0-bibtex-entry-date-fixed " ")
                     " ")
                 sync0-bibtex-entry-title-compatible
                 " in "
                 sync0-bibtex-entry-booktitle
                 (when sync0-bibtex-entry-volume
                   (concat 
                    ", T. "
                    sync0-bibtex-entry-volume
                    (when sync0-bibtex-entry-number
                      (concat 
                       ", No. "
                       sync0-bibtex-entry-number))))
                 (when sync0-bibtex-entry-pages
                   (concat 
                    ", p. "
                    sync0-bibtex-entry-pages))))
        (t (concat sync0-bibtex-entry-lastname
                   (or (concat " " sync0-bibtex-entry-date-fixed " ")
                       " ")
                   sync0-bibtex-entry-title-compatible))))

(defun sync0-bibtex-ocr-language-chooser (bibentry)
  "Choose OCR language(s) based on the BibTeX entry with BIBKEY.
   Returns a string of languages formatted for OCRmyPDF."
  (let* ((raw-languages (or (sync0-bibtex-completion-get-value "languages" bibentry)
                            (sync0-bibtex-completion-get-value "language" bibentry)
                            "")) ;; Default to empty string if nil
         (lang-correspondance-alist '(("german" . "deu")
                                      ("english" . "eng")
                                      ("french" . "fra")
                                      ("spanish" . "spa")
                                      ("portuguese" . "por")
                                      ("italian" . "ita")))
         (langs (mapcar (lambda (lang)
                          (let* ((trimmed-lang (string-trim (downcase (substring-no-properties lang))))
                                 (lang-code (cdr (assoc trimmed-lang lang-correspondance-alist))))
                            (if lang-code
                                lang-code
                              (progn
                                (message "Warning: No OCR language code found for: %s" trimmed-lang)
                                "eng"))))
                        (split-string raw-languages "[, \t\n]")))
         (unique-langs (delete-dups langs)))
    (mapconcat 'identity unique-langs "+")))

(defun sync0-update-bibtex-authors ()
  (interactive)
  (let ((current-authors)
        (final-list)
        (bibtex-authors  (append
                          (mapcar #'(lambda (x) (cdr (assoc "editor" x)))
                                  (bibtex-completion-candidates))
                          (mapcar #'(lambda (x) (cdr (assoc "author" x)))
                                  (bibtex-completion-candidates)))))
    (with-temp-buffer
      (insert-file-contents "~/.emacs.d/sync0-vars/bibtex-authors.txt")
      (goto-char (point-min))
      ;; (keep-lines "contexts" (point-min) (point-max)) 
      (while (re-search-forward "^\\([[:print:]]+\\)\n" (point-max) t)
        (push  (match-string 1) current-authors)))
    (with-temp-file
        "~/.emacs.d/sync0-vars/bibtex-authors.txt"
      (setq final-list (delete-dups (append current-authors bibtex-authors)))
      (sync0-insert-elements-of-list final-list))))

(defun sync0-bibtex-completion-reverse-author (key)
  "Reverse the author used for "
  (let* ((string-key (number-to-string key))
         (author (sync0-org-ref-get-citation-author string-key)))
    (cond ((string-match " and " author)
           ;; create a list with parts 
           (let* ((author-list  (split-string author " and "))
                  (names (let (x)
                           (dolist  (element author-list x)
                             (setq x (concat x
                                             (progn
                                               (string-match ", \\([[:graph:]]+\\)$"   element)
                                               (match-string 1 element))
                                             " "
                                             (progn
                                               (string-match "\\([[:graph:]]+\\),"   element)
                                               (match-string 1 element))
                                             ", "))))))
             (substring names 0 -2)))
          ;; check when author is an organization
          ((string-match "^{" author)
           (string-match "{\\([[:print:]]+\\)}" author)
           (match-string 1 author))
          ;; other cases
          (t (let* ((author-list (split-string author ", "))
                    (last-name (nth 0 author-list))
                    (first-name (nth 1 author-list)))
               (concat first-name " " last-name))))))


(provide 'sync0-ivy-bibtex)
