(defun sync0-bibtex-choose-key (&optional multiple query-message)
  "Allow selection of one or multiple BibTeX keys using citar and return them.
If MULTIPLE is non-nil, allows selection of multiple keys.
QUERY-MESSAGE is the prompt to display when selecting entries."
  (interactive)
  (let* ((my-message (or query-message "Choose BibTeX key: "))
         (selected-keys (citar-select-refs)))
    (if (> (length selected-keys) 1)
        (progn
          (message "Selected keys: %s" selected-keys)
          selected-keys)
      (progn
        (message "Selected key: %s" (car selected-keys))
        (car selected-keys)))))

(defun sync0-bibtex-get-value (field entry)
  "Fix a redefinition of bibtex-completion-get-value because it
outputs the bibtex fields with the braces {}."
      (citar-get-value field entry))

(defun sync0-bibtex-get-value-from-entry  (bibkey bibtex-field)
  "Get content of BIBTEX-FIELD from the entry associated with
BIBKEY. Depends on bibtex-completion-get-entry from the package
helm-bibtex to work"
  (let ((bibentry (citar-get-entry bibkey)))
	(cdr (assoc bibtex-field  bibentry))))

(defun sync0-bibtex-get-citation-author (key)
  "Get the year of an entry with KEY.  Return year as a string."
  (let* ((entry (citar-get-entry key))
         (type (cdr (assoc "=type=" entry))))
    (if (or (equal type "collection")
            (equal type "Collection"))
        (cdr (assoc "editor" entry))
      (cdr (assoc "author" entry)))))

(defun sync0-bibtex-choose-attachment (&optional bibkey extension)
  "Choose an attachment associated with BIBKEY. Optionally filter by EXTENSION.
  Always return the file path of the selected attachment."
  (let* ((refkey (or bibkey
                     (sync0-bibtex-choose-key "Which key to look for attachments?")))
         (file-field (citar-get-value "file" refkey))
         (attachments (when file-field
                        (mapcar (lambda (attachment)
                                  (let* ((cleaned-attachment (string-remove-prefix ":" attachment))  ;; Remove leading colon
                                         (path-and-ext (split-string cleaned-attachment ":"))  ;; Split by colon
                                         (path (car path-and-ext))  ;; Get the path
                                         (ext (cadr path-and-ext)))  ;; Get the extension
                                    (cons path ext)))  ;; Pair path with extension
                                ;; Split on semicolons, ignoring empty strings
                                (split-string file-field ";" t)))))
    (cond
     ((null attachments)
      (error "No attachments found for entry %s" refkey))
     ((= (length attachments) 1)
      (car (car attachments)))  ;; Return the single attachment's path if only one is found
     (t
      (let* ((filtered-attachments
              (if extension
                  (cl-remove-if-not (lambda (attachment)
                                      (string-equal (cdr attachment) extension)) attachments)
                attachments))  ;; Filter by extension if provided
             (choices (mapcar (lambda (attachment) (car attachment)) filtered-attachments)))  ;; Extract only paths
        (if filtered-attachments
            (let ((chosen (completing-read "Select an attachment: " choices)))
              (car (assoc chosen filtered-attachments)))  ;; Return the path of the chosen attachment
          (error "No attachments with the %s extension found" extension)))))))

(defun sync0-bibtex-correct-crossref-fields ()
  "Correct crossref fields to prevent errors generated by the way
bibtex-completion handles crossreferences."
  (setq sync0-bibtex-entry-crossref-entry
        (citar-get-entry sync0-bibtex-entry-crossref))
  ;; when crossref is present, load crossref fields
  (let (x)
    (dolist (element sync0-bibtex-fields x)
      (let ((value (citar-get-value element sync0-bibtex-entry-crossref-entry))
            (var (concat "sync0-bibtex-entry-crossref-" element)))
        ;; set the variable to the value
        (set (intern var) value)
        ;; create cons of the form  ("sync0-bibtex-entry-title" . "The good old days") for an alist
        (push (cons var value) x)
        ;; added this last function to see if I can get completion to work
        (sync0-bibtex-update-var element)))
    (setq sync0-bibtex-entry-crossref-fields-alist x))
  ;; Check and fix problems with crossref-fields
  (dolist (element sync0-bibtex-entry-crossref-crosscheck-fields-list)
    (let* ((entry-element (concat "sync0-bibtex-entry-" element))
           (entry-cons (assoc entry-element sync0-bibtex-entry-fields-alist))
           (entry-value (cdr entry-cons))
           (crossref-element (concat "sync0-bibtex-entry-crossref-" element))
           (crossref-cons (assoc crossref-element sync0-bibtex-entry-crossref-fields-alist))
           (crossref-value (cdr crossref-cons)))
      (when (string= entry-value crossref-value)
        (set (intern entry-element) nil)))))



(defun sync0-bibtex-reverse-author (key)
  "Reverse the author used for "
  (let* ((string-key (number-to-string key))
         (author (sync0-bibtex-get-citation-author string-key)))
    (cond ((string-match " and " author)
           ;; create a list with parts 
           (let* ((author-list  (split-string author " and "))
                  (names (let (x)
                           (dolist  (element author-list x)
                             (setq x (concat x
                                             (progn
                                               (string-match ", \\([[:graph:]]+\\)$"   element)
                                               (match-string 1 element))
                                             " "
                                             (progn
                                               (string-match "\\([[:graph:]]+\\),"   element)
                                               (match-string 1 element))
                                             ", "))))))
             (substring names 0 -2)))
          ;; check when author is an organization
          ((string-match "^{" author)
           (string-match "{\\([[:print:]]+\\)}" author)
           (match-string 1 author))
          ;; other cases
          (t (let* ((author-list (split-string author ", "))
                    (last-name (nth 0 author-list))
                    (first-name (nth 1 author-list)))
               (concat first-name " " last-name))))))

(defun sync0-bibtex-ocr-language-chooser (bibentry)
  "Choose OCR language(s) based on the BibTeX entry with BIBKEY.
   Returns a string of languages formatted for OCRmyPDF."
  (let* ((raw-languages (or (citar-get-value "languages" bibentry)
                            (citar-get-value "language" bibentry)
                            "")) ;; Default to empty string if nil
         (lang-correspondance-alist '(("german" . "deu")
                                      ("english" . "eng")
                                      ("french" . "fra")
                                      ("spanish" . "spa")
                                      ("portuguese" . "por")
                                      ("italian" . "ita")))
         (langs (mapcar (lambda (lang)
                          (let* ((trimmed-lang (string-trim (downcase (substring-no-properties lang))))
                                 (lang-code (cdr (assoc trimmed-lang lang-correspondance-alist))))
                            (if lang-code
                                lang-code
                              (progn
                                (message "Warning: No OCR language code found for: %s" trimmed-lang)
                                "eng"))))
                        (split-string raw-languages "[, \t\n]")))
         (unique-langs (delete-dups langs)))
    (mapconcat 'identity unique-langs "+")))


(provide 'sync0-citar)
