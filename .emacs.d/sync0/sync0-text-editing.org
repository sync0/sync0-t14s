* Faces & Text

    Adjust font size according to screen resolution (when I use dual monitor setup)
#+BEGIN_SRC emacs-lisp
  (if (> (display-pixel-width) 1900)
      ;; high resolution font size (t14s)
      (progn (set-face-attribute 'default nil 
                            :family "Inconsolata"
                            :height 175)
                            ;;:height 170
        (setq line-spacing 0.2))
    ;; low resolution font size
    (progn (set-face-attribute 'default nil 
                          :family "Inconsolata"
                          :height 130)
      (setq line-spacing 0.1)))

  ;;   (defun sync0-buffer-face-mode-fixed ()
  ;;     "Set font to a variable width (proportional) fonts in current buffer"
  ;; (if (> (display-pixel-width) 1900)
  ;;     ;; external monitor font size
  ;;     (progn 
  ;;         (setq buffer-face-mode-face '(:family "Inconsolata" :height 150))
  ;;         (setq line-spacing 0))
  ;;   ;; laptop font size
  ;;   (progn 
  ;;       (setq buffer-face-mode-face '(:family "Inconsolata" :height 155))
  ;;     (setq line-spacing 0.5)))
  ;;     (buffer-face-mode))
 #+END_SRC

  Configure variable-width faces.
  #+BEGIN_SRC emacs-lisp
    (defun sync0-buffer-face-mode-variable ()
      "Set font to a variable width (proportional) fonts in current buffer"
      (if (> (display-pixel-width) 1900)
      ;; high resolution font size (t14s)
        (progn
          (setq buffer-face-mode-face '(:family "Minion Pro" :height 230))
          ;;(setq buffer-face-mode-face '(:family "Minion Pro" :height 200))
      (setq line-spacing 0.35))
      ;; low resolution font size
        (progn
        ;; (setq buffer-face-mode-face '(:family "Minion Pro" :height 155))
         (setq buffer-face-mode-face '(:family "Minion Pro" :height 130))
      ;; (setq line-spacing 0.2)
      (setq line-spacing 0.25)))
      (buffer-face-mode))
 #+END_SRC

    Configure default font faces for Info, ERC, and Org
#+BEGIN_SRC emacs-lisp
  (add-hook 'erc-mode-hook 'sync0-buffer-face-mode-variable)
  (add-hook 'Info-mode-hook 'sync0-buffer-face-mode-variable)
  (add-hook 'text-mode-hook 'sync0-buffer-face-mode-variable)
 #+END_SRC

#+BEGIN_SRC emacs-lisp
  ;; End sentences with a single espace.
  (setq-default sentence-end-double-space nil
                header-line-format " "
                ;; Use spaces instead of tabs
                indent-tabs-mode nil              
                ;; disable bidirectional text for tiny performance boost
                bidi-display-reordering nil 
                ;; Never truncate lines
                truncate-lines t
                truncate-partial-width-windows t
                ;; Help with displaying fonts
                inhibit-compacting-font-caches t)
 #+END_SRC

* auto-fill

 #+BEGIN_SRC emacs-lisp
   (use-package auto-fill
     :straight nil
     :hook 
     (text-mode . turn-on-auto-fill)
     (mu4e-compose-mode . turn-off-auto-fill)
     (mu4e-view-mode . turn-off-auto-fill)
     :preface
     ;; Configure exceptions for auto-fill mode. 
     (defun sync0-nobreak-p ()
       (and (looking-at "+[[:alnum:]]")
            (looking-back "^\\\[A-z]+{.+" (line-beginning-position))))
     ;; Define column width for auto-fill mode. 
     :custom
     (fill-column 66)
     :config
     ;; Respect de la typographie française par auto-fill mode.
     ;; (setq fill-nobreak-predicate '(fill-french-nobreak-p))
     ;; Set hook for exceptions to auto-fill-mode.
     (add-hook 'fill-nobreak-predicate #'sync0-nobreak-p))
  #+END_SRC

* no-break-fade
#+BEGIN_SRC emacs-lisp
  (use-package nobreak-fade 
  :straight nil
  :after auto-fill 
  :defer t
  :load-path "~/.emacs.d/sync0/nobreak-fade.el" 
    ;; :command nobreak-fade
    :config
    (autoload 'nobreak-fade-single-letter-p "nobreak-fade")
    ;; (add-hook 'tex-mode-hook 'nobreak-fade)
    (add-hook 'fill-nobreak-predicate 'nobreak-fade-single-letter-p))
#+END_SRC

* visual-line
#+BEGIN_SRC emacs-lisp


  (use-package visual-line
    :straight nil
    :commands visual-line-mode
    :hook 
    ;; (mu4e-compose-mode . visual-line-mode)
    (mu4e-view-mode . visual-line-mode) 
    (mu4e-compose-mode . visual-line-mode))
#+END_SRC

* visual-fill-column
#+BEGIN_SRC emacs-lisp

;; (straight-use-package '(visual-fill-column :type git :host github :repo "joostkremers/visual-fill-column"))

  (use-package visual-fill-column
    :straight (visual-fill-column :type git :host github :repo "joostkremers/visual-fill-column")
    :commands visual-fill-column-mode
    :hook 
    (mu4e-view-mode . visual-fill-column-mode)
    (mu4e-compose-mode . visual-fill-column-mode)
    ;; (add-hook 'mu4e-view-mode-hook 'mu4e-view-fill-long-lines)
    :config (setq visual-fill-column-width 66))
#+END_SRC

* abbrev

#+BEGIN_SRC emacs-lisp
  (use-package abbrev
    :straight nil
    :custom
    ;; Tell Emacs where to read abbrevs.  
    (abbrev-file-name "~/.emacs.d/abbrev_defs")
    ;; Save abbrevs when files are saved.
    (save-abbrevs t)
    ;; Don't notify when abbrevs are saved.
    (save-abbrevs 'silently)
    ;; Accept ' as a word constituent. 
    (dabbrev-abbrev-char-regexp  "\\sw")
    :config 
    ;; Avoid errors when reading abbrev_defs.
    (if (file-exists-p abbrev-file-name)
        (quietly-read-abbrev-file))

    ;; Avoid expansion character insertion. 
    ;; Use this function on a per-abbrev basis.
    ;; This is the "hook" function
    (defun dont-insert-expansion-char ()  t) 
    ;; The hook should have a "no-self-insert" property set 
    (put 'dont-insert-expansion-char 'no-self-insert t) 

    ;; Initialize abbrev-mode by default. 
    (setq-default abbrev-mode t)

    ;; Add abbrevs manually.
    (defun sync0-define-local-abbrev (name expansion)
      "Defines a new abbrev for current local abbrev table."
      (interactive "sEnter abbrev:\nsEnter expansion:")
      (when (and name expansion (not (equal name expansion)))
        (define-abbrev local-abbrev-table name expansion)
        (message "\"%s\" now expands to \"%s\" %sally"
                 name expansion "loc")))

    ;; Auto-update abbrev table on save.
    (add-hook 'after-save-hook (lambda ()
                                 (when (equal buffer-file-name "~/.emacs.d/abbrev_defs")
                                   (read-abbrev-file)))))
  #+END_SRC 

* ispell 
#+BEGIN_SRC emacs-lisp
  (use-package ispell
     :hook (text-mode . ispell-minor-mode)
    :custom
    ;; Save a new word to personal dictionary without asking
    (ispell-silently-savep t)
    ;; Set up hunspell dictionaries
    (ispell-hunspell-dict-paths-alist
     '(("en_US-large" "/usr/share/hunspell/en_US-large.aff")
       ("de_DE" "/usr/share/hunspell/de_DE.aff")
       ("it_IT" "/usr/share/hunspell/it_IT.aff")
       ("es" "/usr/share/hunspell/es.aff")
       ("pt_BR" "/usr/share/hunspell/pt_BR.aff")
       ("fr_FR" "/usr/share/hunspell/fr_FR.aff")))
    :config 
    ;; if hunspell does NOT exist, use aspell
    (cond ((executable-find "hunspell")
           (setq ispell-program-name "hunspell")
           ;;(setq ispell-local-dictionary "en_US")
           (setq ispell-local-dictionary-alist '(("en_US-large" "[[:alpha:]]" "[^[:alpha:]]" "['’-]" t ("-d" "en_US-large" ) nil utf-8)
                                                 ("de_DE" "[[:alpha:]ÄÖÜéäöüß]" "[^[:alpha:]ÄÖÜéäöüß]" "['’-]" t ("-d" "de_DE") nil utf-8)
                                                 ("es" "[[:alpha:]ÁÉÍÓÚÄËÏÖÜÑáéíóúäëïöüñ]" "[^[:alpha:]ÁÉÍÓÚÄËÏÖÜÑáéíóúäëïöüñ]" "['’-]" t ("-d" "es") nil utf-8)
                                                 ("pt_BR" "[[:alpha:]a-zàáâãçéêíóôõúüA-ZÀÁÂÃÇÉÊÍÓÔÕÚÜ]" "[^[:alpha:]a-zàáâãçéêíóôõúüA-ZÀÁÂÃÇÉÊÍÓÔÕÚÜ]" "['-]" t  ("-d" "pt_BR") nil utf-8)
                                                 ("it_IT" "[[:alpha:]AEÉIOUàèéìòù]" "[^[:alpha:]AEÉIOUàèéìòù]" "['’-]" t ("-d" "it_IT") nil utf-8)
                                                 ("fr_FR" "[[:alpha:]ÀÂÇÈÉÊËÎÏÔÙÛÜàâçèéêëîïôùûü]" "[^[:alpha:]ÀÂÇÈÉÊËÎÏÔÙÛÜàâçèéêëîïôùûü]" "[’'-]" t ("-d" "fr_FR")  nil utf-8))))

          ((executable-find "aspell")
           (setq ispell-program-name "aspell")
           ;; Please note ispell-extra-args contains ACTUAL parameters passed to aspell
           (setq ispell-extra-args '("--sug-mode=ultra"))))

    ;; This functions was borrowed from Artur Malabarba. See his discussion
    ;; here:
    ;; http://endlessparentheses.com/ispell-and-abbrev-the-perfect-auto-correct.html

    ;; Ignore sections of files for spellcheck
    (add-to-list 'ispell-skip-region-alist '(":\\(PROPERTIES\\|LOGBOOK\\):" . ":END:"))
    (add-to-list 'ispell-skip-region-alist '("#\\+BEGIN_SRC" . "#\\+END_SRC"))
    (add-to-list 'ispell-skip-region-alist '("#\\+BEGIN_EXAMPLE" . "#\\+END_EXEMPLE"))
    (add-to-list 'ispell-skip-region-alist '("#\\+BEGIN_equation" . "#\\+END_equation"))
    (add-to-list 'ispell-skip-region-alist '("#\\+BEGIN_labeling" . "#\\+END_labeling"))
    (add-to-list 'ispell-skip-region-alist '("#\\+[A-z]+: .+$"))
    (add-to-list 'ispell-skip-region-alist '("\\[\\[" . "\\]\\]"))
    (add-to-list 'ispell-skip-region-alist '("#\\+BEGIN_equation*" . "#\\+END_equation*"))
    (add-to-list 'ispell-skip-region-alist '("#\\+BEGIN_align" . "#\\+END_align"))
    (add-to-list 'ispell-skip-region-alist '("#\\+BEGIN_align*" . "#\\+END_align*"))
    (add-to-list 'ispell-skip-region-alist '(org-property-drawer-re))
    (add-to-list 'ispell-skip-region-alist '("\\$" . "\\$")))
#+END_SRC 

* flyspell
 #+BEGIN_SRC emacs-lisp
   (use-package flyspell 
     :diminish flyspell-mode
     :hook (text-mode . flyspell-mode)
     :custom
     (ispell-parser 'tex)
     (flyspell-issue-message-flag nil))
 #+END_SRC 

* guess-language
Emacs minor mode that detects the language you're typing in.
Automatically switches spell checker. Supports multiple languages
per document.

#+BEGIN_SRC emacs-lisp
      (use-package guess-language
        :straight (guess-language :type git :host github :repo "tmalsburg/guess-language.el") 
        :after ispell 
        :hook (text-mode . guess-language-mode)
        :init
        (set-input-method nil)

        (defvar sync0-language-active 'english
          "Currently active natural language")

        :custom
        (guess-language-languages '(en it pt de fr es))
        (guess-language-min-paragraph-length 30)
        (guess-language-langcodes
         '((en . ("en_US-large" "english"))
           (it . ("it_IT" "italian"))
           (pt . ("pt_BR" "portuguese"))
           (de . ("de_DE" "german"))
           (fr . ("fr_FR" "french"))
           (es . ("es" "spanish"))))

        :config 
        (defun sync0-language-change (lang beginning end)
          "Set of functions to run after a different language is detected."
          (unless (string-equal guess-language-current-language lang)
            (cond 
             ((string-equal lang "es")
              (progn
                (setq sync0-language-active "spanish")
                (setq local-abbrev-table spanish-mode-abbrev-table)
                (set-input-method "spanish-prefix")
                (ispell-change-dictionary "es")))
             ((string-equal lang "de")
              (progn
                (setq sync0-language-active "german")
                (setq local-abbrev-table german-mode-abbrev-table)
                (set-input-method "german-prefix")
                (ispell-change-dictionary "de_DE")))
             ((string-equal lang "pt")
              (progn
                (setq sync0-language-active "portuguese")
                (setq local-abbrev-table portuguese-mode-abbrev-table)
                (set-input-method "portuguese-prefix")
                (ispell-change-dictionary "pt_BR")))
             ((string-equal lang "fr")
              (progn
                (setq sync0-language-active "french")
                (setq local-abbrev-table french-mode-abbrev-table)
                (set-input-method "french-prefix")
                (ispell-change-dictionary "fr_FR")))
             ((string-equal lang "it")
              (progn
                (setq sync0-language-active "italian")
                (setq local-abbrev-table italian-mode-abbrev-table)
                (set-input-method "italian-postfix")
                (ispell-change-dictionary "it_IT")))
             ((string-equal lang "en")
              (progn
                (setq sync0-language-active "english")
                (setq local-abbrev-table english-mode-abbrev-table)
                (set-input-method nil)
                (ispell-change-dictionary "en_US-large"))))))

    (defvar sync0-change-language-actions-alist
      '((?1 "en" (lambda ()
                (progn
                  (setq  guess-language-current-language 'en)
                  (setq sync0-language-active "english")
                  (setq local-abbrev-table english-mode-abbrev-table)
                  (set-input-method nil)
                  (ispell-change-dictionary "en_US-large"))))
        (?2 "es" (lambda ()
              (progn
                (setq  guess-language-current-language 'es)
                (setq sync0-language-active "spanish")
                (setq local-abbrev-table spanish-mode-abbrev-table)
                (set-input-method "spanish-prefix")
                (ispell-change-dictionary "es"))))
        (?3 "pt" (lambda ()
              (progn
                (setq  guess-language-current-language 'pt)
                (setq sync0-language-active "portuguese")
                (setq local-abbrev-table portuguese-mode-abbrev-table)
                (set-input-method "portuguese-prefix")
                (ispell-change-dictionary "pt_BR"))))
        (?4 "fr" (lambda ()
              (progn
                  (setq  guess-language-current-language 'fr)
                (setq sync0-language-active "french")
                (setq local-abbrev-table french-mode-abbrev-table)
                (set-input-method "french-prefix")
                (ispell-change-dictionary "fr_FR"))))
        (?5 "it" (lambda ()
              (progn
                  (setq  guess-language-current-language 'it)
                (setq sync0-language-active "italian")
                (setq local-abbrev-table italian-mode-abbrev-table)
                (set-input-method "italian-postfix")
                (ispell-change-dictionary "it_IT"))))
        (?6 "de" (lambda ()
              (progn
                  (message "Deutsch ist die aktuelle Sprache")
                  (setq  guess-language-current-language 'de)
                (setq sync0-language-active "german")
                (setq local-abbrev-table german-mode-abbrev-table)
                (set-input-method "german-prefix")
                (ispell-change-dictionary "de_DE")))))
      "List that associates number letters to descriptions and actions.")

    (defun sync0-change-current-language ()
      "Lets the user choose the animal and takes the corresponding action.
    Returns whatever the action returns."
      (interactive)
      (let ((choice
             (read-char-choice
              (mapconcat
               (lambda (item) (format "[%c] %s" (car item) (cadr item)))
               sync0-change-language-actions-alist " ")
                      (mapcar #'car sync0-change-language-actions-alist))))
        (funcall (nth 2 (assoc choice sync0-change-language-actions-alist)))))

      (defun sync0-ispell-get-word ()
        (car-safe (save-excursion (ispell-get-word nil))))

      (defun sync0-ispell-word-then-abbrev ()
        "Call `ispell-word', then create an abbrev for it.
      With prefix P, create local abbrev. Otherwise it will
      be global.
      If there's nothing wrong with the word at point, keep
      looking for a typo until the beginning of buffer. You can
      skip typos you don't want to fix with `SPC', and you can
      abort completely with `C-g'."
        (interactive)
        (let (bef aft)
          (save-excursion
            (while (if (setq bef (sync0-ispell-get-word))
                       ;; Word was corrected or used quit.
                       (if (ispell-word nil 'quiet)
                           nil ; End the loop.
                         ;; Also end if we reach `bob'.
                         (not (bobp)))
                     ;; If there's no word at point, keep looking
                     ;; until `bob'.
                     (not (bobp)))
              (backward-word)
              (backward-char))
            (setq aft (sync0-ispell-get-word)))
          (if (and aft bef (not (equal aft bef)))
              (let ((aft (downcase aft))
                    (bef (downcase bef)))
    ;; (unless
    ;;  (save-excursion
    ;;   (with-temp-buffer
    ;;    (insert-file-contents company-ispell-dictionary)
    ;;    (goto-char (point-min))
    ;;    (re-search-forward (concat "^" aft) nil t 1)))
    ;;    (write-region (concat aft "\n") nil company-ispell-dictionary 'append))
                (define-abbrev local-abbrev-table bef aft)
                (message "\"%s\" now expands to \"%s\" %sally"
                         bef aft "loc"))
            (user-error "No typo at or before point"))))

        (defun sync0-lookup-word (word)
          "Search an online dictionary for the word at point according
            to the active language minor mode."
          (interactive (list (save-excursion (car (ispell-get-word nil)))))
          (cond  ((string-equal guess-language-current-language "en") 
                  (browse-url (format "https://www.merriam-webster.com/dictionary/%s" word)))
                 ((string-equal guess-language-current-language "de") 
                  (browse-url (format "https://www.duden.de/rechtschreibung/%s" word)))
                 ((string-equal guess-language-current-language "it") 
                  (browse-url (format "https://www.duden.de/rechtschreibung/%s" word)))
                 ((string-equal guess-language-current-language "pt") 
                  (browse-url (format "https://www.dicio.com.br/%s" word)))
                 ((string-equal guess-language-current-language "fr") 
                  (browse-url (format "https://dictionnaire.lerobert.com/definition/%s#definitions" word)))
                 ((string-equal guess-language-current-language "es") 
                  (browse-url (format "https://dle.rae.es/?w=%s" word)))
                 (t "No language minor mode specified")))

        (defun sync0-lookup-conjugation (word)
          "Search an online dictionary for the word at point according
            to the active language minor mode."
          (interactive (list (save-excursion (car (ispell-get-word nil)))))
          (cond  ((string-equal guess-language-current-language "en") 
                  (browse-url (format "https://www.merriam-webster.com/dictionary/%s" word)))
                 ((string-equal guess-language-current-language "de") 
                  (browse-url (format "https://www.verbformen.de/konjugation/?w=%s" word)))
                 ((string-equal guess-language-current-language "it") 
                  (browse-url (format "https://www.verbformen.de/konjugation/?w=%s" word)))
                 ((string-equal guess-language-current-language "pt") 
                  (browse-url (format "https://www.conjugacao.com.br/verbo-%s/" word)))
                 ((string-equal guess-language-current-language "fr") 
                  (browse-url (format "http://la-conjugaison.nouvelobs.com/du/verbe/%s.php" word)))
                 ((string-equal guess-language-current-language "es") 
                  (browse-url (format "http://conjugador.reverso.net/conjugacion-espanol-verbo-%s.html" word)))
                 (t "No language minor mode specified")))

        (defun sync0-lookup-thesaurus (word)
          "Search an online dictionary for the word at point according
            to the active language minor mode."
          (interactive (list (save-excursion (car (ispell-get-word nil)))))
          (cond  ((string-equal guess-language-current-language "en") 
                  (browse-url (format "https://www.merriam-webster.com/thesaurus/%s" word)))
                 ((string-equal guess-language-current-language "fr") 
                  (browse-url (format "https://dictionnaire.lerobert.com/definition/%s#synonymes" word)))
                 ((string-equal guess-language-current-language "de") 
                  (browse-url (format "https://www.duden.de/rechtschreibung/%s#synonyme" word)))
                 ((string-equal guess-language-current-language "it") 
                  (browse-url (format "https://www.duden.de/rechtschreibung/%s#synonyme" word)))
                 ((string-equal guess-language-current-language "pt") 
                  (browse-url (format "https://www.dicio.com.br/%s" word)))
                 ((string-equal guess-language-current-language "es") 
                  (browse-url (format "http://conjugador.reverso.net/conjugacion-espanol-verbo-%s.html" word)))
                 (t "No language minor mode specified")))

  (defun sync0-guess-language-set-parts-of-speech ()
  "Choose parts of speech according to active language"
  (let* ((parts-list (list ()))
         (lang (prin1-to-string guess-language-current-language)))
    (cond ((string-equal lang "es")
           (progn
           (setq parts-list sync0-spanish-parts-speech)
            (ivy-completing-read "Elija uno: " parts-list)))
          ((string-equal lang "pt")
           (progn
           (setq parts-list sync0-portuguese-parts-speech)
            (ivy-completing-read "Escolha um: " parts-list)))
          ((string-equal lang "it")
           (progn
           (setq parts-list sync0-portuguese-parts-speech)
            (ivy-completing-read "Escolha um: " parts-list)))
           ((string-equal lang "fr")
           (progn
            (setq parts-list sync0-french-parts-speech)
            (ivy-completing-read "Choississez un : " parts-list)))
           ((string-equal lang "en")
           (progn
            (setq parts-list sync0-english-parts-speech)
             (ivy-completing-read "Choose one: " parts-list)))
                 (t "No language minor mode specified"))))

        (defhydra sync0-hydra-language-functions (:color amaranth :hint nil :exit t)
          "
     ^Language functions^
     ^^^------------------------
     Show _d_efinition
     Show _c_onjugation
     Show in _t_hesaurus

     _q_uit
        "
          ;; Quickly work with bookmarks
          ("d" sync0-lookup-word)
          ("i" sync0-ispell-word-then-abbrev)
          ("c" sync0-lookup-conjugation)
          ("t" sync0-lookup-thesaurus)
          ("q"  nil :color blue))

(evil-leader/set-key
  "L" 'sync0-ispell-word-then-abbrev
  "l" 'sync0-hydra-language-functions/body)

        (add-hook 'guess-language-after-detection-functions #'sync0-language-change)

        :bind (("M-#" . sync0-lookup-word)
               ("M-i" . sync0-ispell-word-then-abbrev)
               ;; ("C-d" . sync0-hydra-language-functions/body)
               ("M-$" . sync0-lookup-conjugation)))
#+END_SRC 

* 取 festival
This package simply reads aloud text selections. If this functionality
seems trivial, as an academic writer, it has proven quite useful. Use
it to improve the /feel/ (cadence and rhythm) of your writing. 

Caveat: Getting this package to work was a PITA; on top of the
installation, you must rummage the internet for the voices. The
default voices are just not usable. As an Arch Linux user, I found
some quality voices in the AUR repositories.

#+BEGIN_SRC emacs-lisp
  (use-package festival 
    :straight nil
    :disabled t
    :defer t
    :load-path "~/.emacs.d/sync0/" 
    :commands say-minor-mode
    :config
    (autoload 'say-minor-mode "festival" "Menu for using Festival." t)
    ;; (say-minor-mode t)

    (defun sync0-festival-el () 
      (interactive)
      (festival-send-command '(voice_el_diphone)))

    (defun sync0-festival-english-male () 
      (interactive)
      (festival-send-command '(voice_nitech_us_awb_arctic_hts)))

    (defun sync0-festival-english-female () 
      (interactive)
      (festival-send-command '(voice_nitech_us_slt_arctic_hts)))

    :bind (:map evil-visual-state-map 
          ("s" . festival-say-region)))
  #+END_SRC 

* focus-mode
  Focus provides focus-mode that dims the text of surrounding sections.
  This mode is perfect for proofreading. Thus, don't abuse it when
  writing drafts.  

  The amount of dimness can be customized by setting the focus-dimness
  variable, where a positive integer indicates a more dim color (i.e.
  more blended with the background color of your theme), and a negative
  integer indicates a less dim color.

  #+BEGIN_SRC emacs-lisp
  (use-package focus
    :straight (focus :type git :host github :repo "larstvei/Focus") 
    :commands focus-mode)
  #+END_SRC 

* centered-window-mode
  Center text. 
#+BEGIN_SRC emacs-lisp
  (use-package centered-window
                      :straight (centered-window :type git :host github :repo "anler/centered-window-mode") 
                      :config

                  (defun sync0-text-mode-centered-window ()
        "Set font to a variable width (proportional) fonts in current buffer"
        (if (> (display-pixel-width) 1900)
        ;; high resolution (t14s)
          (progn
                ;; (setq cwm-left-fringe-ratio 80)
                (setq cwm-left-fringe-ratio 50)
              (centered-window-mode t))
        ;; low resolution 
          (progn
                (setq cwm-left-fringe-ratio 100)
              (centered-window-mode t))))

                  (defun sync0-prog-mode-centered-window ()
                   (progn
              ;; Ratio by which the left fringe is padded more than the right.
              ;; Should be a value between 0 and 100
              (setq cwm-left-fringe-ratio 30)
              (centered-window-mode t)))

                      :hook 
              ((text-mode . sync0-text-mode-centered-window)
               ;; (mu4e-compose-mode . sync0-text-mode-centered-window)
               ;; (mu4e-view-mode . sync0-text-mode-centered-window)
               (prog-mode . sync0-prog-mode-centered-window)))

  #+END_SRC 

* olivetti
  Center text. It is unusable in split screen setups. 
  #+BEGIN_SRC emacs-lisp

      (use-package olivetti
        :disabled t
        :straight (olivetti :type git :host github :repo "rnkn/olivetti") 
        :commands olivetti-mode
        :config
    (defun sync0-text-mode-olivetti ()
     (progn
      (olivetti-set-width 66)
     (olivetti-mode 1)))

    (defun sync0-prog-mode-olivetti ()
     (progn
      (olivetti-set-width 80)
     (olivetti-mode 1))))

        ;; :hook 
        ;; ((text-mode . sync0-text-mode-olivetti)
        ;;  (prog-mode . sync0-prog-mode-olivetti))

  #+END_SRC 
  
* follow-mode 
This mode allows the continuation of text in other buffers.
It is useful, specially in smaller displays, when editing
long texts to take advantage of screen real state to the
maximum.

#+BEGIN_SRC emacs-lisp
(use-package follow-mode
 :straight nil
 :commands follow-mode
 :custom (follow-auto t)
 :bind ("C-c f" . follow-delete-other-windows-and-split))
  #+END_SRC 
